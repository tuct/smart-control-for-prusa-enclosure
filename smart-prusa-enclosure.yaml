substitutions:
  node_name: smart-prusa-enclosure
  id_prefix: smart_prusa_enclosure
  name: Prusa Enclosure
esphome:
  name: ${node_name}
  on_boot:
    - priority: 600
      then:
        - script.execute:
            id: display_off_timer
    - priority: 1000
      then:
        - switch.turn_on: printer_relais

esp32:
  board: az-delivery-devkit-v4
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: <Role your own>=

ota:
  password: "<Role your own>"

wifi:
  ssid: "<Role your own>"
  password: "<Role your own>"
# Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${name}"
    password: "<Role your own>"

captive_portal:
#Timer is used to track air filter runtime
time:
  - platform: sntp
    id: sntp_time
    on_time:
        # Every 1 minutes
        - seconds: 0
          minutes: /1
          then:
            - logger.log: "one minute later"
            - lambda: |
                auto idFilterOn = id(filter_a).current_values.is_on();
                if(idFilterOn){
                  id(filter_runtime_value) = id(filter_runtime_value)+1;
                }
#SPI  and i2c setup + io expander 
spi:
  clk_pin: GPIO14
  mosi_pin: GPIO26
i2c:
  sda: GPIO21
  scl: GPIO22
  frequency: 100kHz
mcp23017:
  - id: 'mcp23017_hub'
    address: 0x20

# global variables used to settings by user 
globals:
  - id: auto_filter_pm_min_value
    type: int
    restore_value: yes
    initial_value: '150'
  - id: auto_filter_voc_min_value
    type: int
    restore_value: yes
    initial_value: '120'
  - id: light_a_brightness
    type: int
    restore_value: yes
    initial_value: '100'
  - id: filter_a_speed
    type: int
    restore_value: yes
    initial_value: '100'
  - id: fan_a_speed
    type: int
    restore_value: yes
    initial_value: '100'
  - id: filter_a_auto
    type: int
    restore_value: yes
    initial_value: '1'
  - id: ac_active
    type: int
    restore_value: yes
    initial_value: '0'
  - id: ac_target_temp_value
    type: int
    restore_value: yes
    initial_value: '25'
  - id: filter_runtime_value
    type: int
    restore_value: yes
    initial_value: '0'

# this is used to the menu, found the esphoem menu later, maybe oneday i port this!
select:
  - platform: template
    id: display_mode
    optimistic: true
    internal: true
    options:
      - environment
      - settings
      - single
      - display_off
    initial_option: environment
    set_action:
      - display.page.show: !lambda |-
          if (strcmp(x.c_str(), "settings") == 0 || strcmp(x.c_str(), "single") == 0) {
            return id(page_settings);
          } else {
            return id(page_environment);
          }

  - platform: template
    id: settings
    optimistic: true
    options:
      - ac_mode
      - ac_target_temp
      - default_light_brightness
      - default_filter_speed
      - default_fan_speed
      - auto_filter
      - auto_filter_pm_min
      - auto_filter_voc_min
      - filter_runtime
      - back
    initial_option: ac_mode

#Scripts to control the logic    
script:
  - id: display_off_timer
    mode: restart    
    then:
      - if: 
          condition: 
            lambda: 'return (strcmp(id(display_mode).state.c_str(), "display_off") == 0 );'
          then: 
            - light.turn_on:
                id: lcd_light
            - select.set:
                id: display_mode
                option: "environment"
      - if: 
          condition: 
            lambda: 'return (strcmp(id(display_mode).state.c_str(), "environment") == 0 );'
          then:
            - delay: 1min 
            - select.set:
                id: display_mode
                option: "display_off"
            - light.turn_off:
                id: lcd_light
          else: 
            - delay: 5s
            - select.set:
                id: display_mode
                option: "environment"
            - script.execute:
                id: display_off_timer

  - id: update_light # update the light brightness based on setting
    mode: queued 
    then:
      - lambda: |-
          float brightness= ((float)id(light_a_brightness)/100);
          auto call = id(light_a).turn_on();
          call.set_transition_length(0); // in ms
          call.set_brightness(brightness);
          call.perform();
  - id: update_filter # update the filter speed based on setting
    mode: queued 
    then:
      - lambda: |-
          auto currentState = id(filter_a).current_values.is_on();
          auto currentValue = id(filter_a).current_values.get_brightness();
          if(id(switch_filter).state){ // filter on
            float speed= ((float)id(filter_a_speed)/100);
            if(id(filter_a_auto) == 1){
              if(currentState == 1 && id(auto_filter_sensor).state == 0.0 ){ // turn off if auto says no and currently on
                auto call = id(filter_a).turn_off();
                call.set_transition_length(0); // in ms
                call.set_brightness(0);
                call.perform();
              }
              if((currentState == 0 || currentValue != speed) && id(auto_filter_sensor).state == 1.0 ){ // turn on if auto says yes and currently off
                auto call = id(filter_a).turn_on();
                call.set_transition_length(0); // in ms
                call.set_brightness(speed);
                call.perform();
              }
            }else{
              if(currentState == 0 || currentValue != speed ){
                auto call = id(filter_a).turn_on();
                call.set_transition_length(0); // in ms
                call.set_brightness(speed);
                call.perform();
              }
            }
          }else{
            if(currentState == 1){
              auto call = id(filter_a).turn_off();
              call.set_transition_length(0); // in ms
              call.set_brightness(0);
              call.perform();
            }
          }
  - id: update_fan  # update the filter speed based on setting
    mode: queued 
    then:
      - lambda: |-
          float speed= ((float)id(fan_a_speed)/100);
          auto call = id(fan_a).turn_on();
          call.set_transition_length(0); // in ms
          call.set_brightness(speed);
          call.perform();
  - id: update_ac_target # update the filter speed based on setting
    mode: queued 
    then:
      - lambda: |-
          auto call = id(my_climate).make_call();
          call.set_target_temperature_low(id(ac_target_temp_value));
          call.set_target_temperature_high(id(ac_target_temp_value)+2);
          if(id(ac_active)==1){
            call.set_mode("HEAT_COOL");
          }else{
            call.set_mode("OFF");
          }
          call.perform();
  - id: open_lid # update the filter speed based on setting
    mode: single 
    then:
      - logger.log: OPEN LID START
      - servo.write:
          id: lid_servo
          level: -50.0%
      - delay: 5s 
      - logger.log: OPEN LID DONE
  - id: close_lid # update the filter speed based on setting
    mode: single 
    then:
      - logger.log: CLOSE LID START
      - servo.write:
          id: lid_servo
          level: 2.0%
      - delay: 5s
      - logger.log: CLOSE LID DONE

  - id: update_ac # update the fan speed based and heater on setting
    mode: queued 
    then:
      - lambda: |-
          bool ac_is_active = false;
          float servoOpen = 0.5;
          float servoClosed = 0.0;
          float heaterTempMax = 80.0; // turn off heater if heater temp above!
          float heaterTempMin = 65.0; // turn on heater again
          float heaterTemp =   id(${id_prefix}_temperature_heater).state;

          if(id(ac_active)==1 && !isnan(id(${id_prefix}_temperature_bottom).state)){
            ac_is_active = true;
          }
          bool fan_switch = id(switch_fan).state;
          auto ac_mode = id(my_climate).mode;
          auto ac_action = id(my_climate).action;
          ESP_LOGI("main", "AC Active: %s",ac_is_active?"true":"false");
          ESP_LOGI("main", "Fan switch: %s",fan_switch?"true":"false");
          ESP_LOGI("main", "AC Mode: %d",ac_mode);
          ESP_LOGI("main", "AC Action: %d",ac_action);
          float fan_speed = ((float)id(fan_a_speed)/100);
          if(!fan_switch){
            //fan/ac is dissabled!
            ESP_LOGI("main", "AC: OFF, HEATER: OFF, FAN: OFF, LID: closed!");
            //lid
     
            id(close_lid)->execute();
            //heater
            id(heater_relais).turn_off();
            //fan - off
            auto call = id(fan_a).turn_off();
            call.set_transition_length(0); // in ms
            call.set_brightness(fan_speed); // 1.0 is full brightness
            call.perform();
          }else{
            //fan is active, check if we are in AC mode
            if(ac_is_active){
              if(ac_action == CLIMATE_ACTION_HEATING){
                ESP_LOGI("main", "AC: ON, HEATER: ON, FAN: ON, LID: closed!");
                
                //fan on full

                id(close_lid)->execute();
                if (id(heater_relais).state) {
                  // Heater is on, turn off if above! else on
                  if(heaterTemp <=heaterTempMax){
                    //on if temp below max
                    id(heater_relais).turn_on();
                  }else{
                    //off if above!
                    id(heater_relais).turn_off();
                  }
                } else {
                  // Heater is off, turn on if below 
                  if(heaterTemp <=heaterTempMin){
                    id(heater_relais).turn_on();
                  }else{
                    id(heater_relais).turn_off();
                  }
                }  
                ESP_LOGI("main", "HEATER REAL: %s",(id(heater_relais).state)?"ON":"OFF");
                auto calla = id(fan_a).turn_on();
                calla.set_transition_length(0); // in ms
                calla.set_brightness(fan_speed); // 1.0 is full brightness
                calla.perform();
              }
              if(ac_action == CLIMATE_ACTION_COOLING){
                ESP_LOGI("main", "AC: ON, HEATER: OFF, FAN: ON, LID: open!");
   
                id(open_lid)->execute();
                id(heater_relais).turn_off();
                //fan on full
                auto callb = id(fan_a).turn_on();
                callb.set_transition_length(0); // in ms
                callb.set_brightness(fan_speed); // 1.0 is full brightness
                callb.perform();
              }        
              if(ac_action != CLIMATE_ACTION_HEATING && ac_action != CLIMATE_ACTION_COOLING){
                ESP_LOGI("main", "AC: ON, HEATER: OFF, FAN: OFF, LID: closed!");
                id(heater_relais).turn_off();
      
                id(close_lid)->execute();
                auto callc = id(fan_a).turn_off();
                callc.set_transition_length(0); // in ms
                callc.perform();
              }    

            }else{
              //AC off, 
              ESP_LOGI("main", "AC: OFF, HEATER: OFF, FAN: OFF, LID: closes!");

              id(close_lid)->execute();
              id(heater_relais).turn_off();
              auto callc = id(fan_a).turn_off();
              callc.set_transition_length(0); // in ms
              callc.perform();
            }
          }

  - id: update_setting # used to update the settings
    mode: queued 
    parameters:
      dir: int
    then:
      - lambda: |-
          uint stepSize = 10;
          //for speed/brightness
          uint minValue = 20;
          if(dir==0){ 
          // reduce 
            if(strcmp(id(settings).state.c_str(), "ac_mode")==0){
              if(id(ac_active)==1){
                id(ac_active) = 0;
              }else{
                id(ac_active) = 1;
              }
              id(update_ac_target)->execute();
            } 
            if(strcmp(id(settings).state.c_str(), "ac_target_temp")==0 && id(ac_target_temp_value)>15){
              id(ac_target_temp_value) = id(ac_target_temp_value)-1;
              id(update_ac_target)->execute();
            }  
            if(strcmp(id(settings).state.c_str(), "default_light_brightness")==0 && id(light_a_brightness)>minValue){
              id(light_a_brightness) = id(light_a_brightness)-stepSize;
              //update brightness of light!
              if(id(switch_light).state){
                id(update_light)->execute();
              }
            }
            if(strcmp(id(settings).state.c_str(), "default_filter_speed")==0 && id(filter_a_speed)>minValue){
              id(filter_a_speed) = id(filter_a_speed)-stepSize;
              //update brightness of light!
      
              id(update_filter)->execute();
         
            }   
            if(strcmp(id(settings).state.c_str(), "default_fan_speed")==0 && id(fan_a_speed)>minValue){
              id(fan_a_speed) = id(fan_a_speed)-stepSize;
              //update brightness of light!
              if(id(switch_fan).state){
                id(update_fan)->execute();
              }
            }  
            if(strcmp(id(settings).state.c_str(), "auto_filter")==0){
              if(id(filter_a_auto)==1){
                id(filter_a_auto) = 0;
              }else{
                id(filter_a_auto) = 1;
              }
            } 
            if(strcmp(id(settings).state.c_str(), "auto_filter_pm_min")==0 && id(auto_filter_pm_min_value)>0){
              id(auto_filter_pm_min_value) = id(auto_filter_pm_min_value)-stepSize;
            }  
            if(strcmp(id(settings).state.c_str(), "auto_filter_voc_min")==0 && id(auto_filter_voc_min_value)>0){
              id(auto_filter_voc_min_value) = id(auto_filter_voc_min_value)-stepSize;
            }  
            if(strcmp(id(settings).state.c_str(), "filter_runtime")==0 && id(filter_runtime_value)>0){
              id(filter_runtime_value) = id(filter_runtime_value)-60;
              if(id(filter_runtime_value) < 0) {
                id(filter_runtime_value) = 0;
              }
            }  

          }else{
            // add
            if(strcmp(id(settings).state.c_str(), "ac_mode")==0){
              if(id(ac_active)==1){
                id(ac_active) = 0;
              }else{
                id(ac_active) = 1;
              }
              id(update_ac_target)->execute();
            } 
            if(strcmp(id(settings).state.c_str(), "ac_target_temp")==0 && id(ac_target_temp_value)<50){
              id(ac_target_temp_value) = id(ac_target_temp_value)+1;
              id(update_ac_target)->execute();
            }  
            if(strcmp(id(settings).state.c_str(), "default_light_brightness")==0 && id(light_a_brightness)<100){
              id(light_a_brightness) = id(light_a_brightness)+stepSize;
              //update brightness of light!
              if(id(switch_light).state){
                id(update_light)->execute();
              }
            }
            if(strcmp(id(settings).state.c_str(), "default_filter_speed")==0 && id(filter_a_speed)<100){
              id(filter_a_speed) = id(filter_a_speed)+stepSize;
              //update brightness of light!
              id(update_filter)->execute();
            }
            if(strcmp(id(settings).state.c_str(), "default_fan_speed")==0 && id(fan_a_speed)<100){
              id(fan_a_speed) = id(fan_a_speed)+stepSize;
              //update brightness of light!
              if(id(switch_fan).state){
                id(update_fan)->execute();
              }
            }  
            if(strcmp(id(settings).state.c_str(), "auto_filter")==0){
              if(id(filter_a_auto)==1){
                id(filter_a_auto) = 0;
              }else{
                id(filter_a_auto) = 1;
              }
            }    
            if(strcmp(id(settings).state.c_str(), "auto_filter_pm_min")==0 && id(auto_filter_pm_min_value)<990){
              id(auto_filter_pm_min_value) = id(auto_filter_pm_min_value)+stepSize;
            }  
            if(strcmp(id(settings).state.c_str(), "auto_filter_voc_min")==0 && id(auto_filter_voc_min_value)<500){
              id(auto_filter_voc_min_value) = id(auto_filter_voc_min_value)+stepSize;
            }         
            if(strcmp(id(settings).state.c_str(), "filter_runtime")==0 && id(filter_runtime_value)< 36000){ //60*600 = 36000 = 600h max!
              id(filter_runtime_value) = id(filter_runtime_value)+60;
              if(id(filter_runtime_value) > 36000) {
                id(filter_runtime_value) = 36000;
              }
            }    
          }
        
color:
  - id: my_red
    red: 100%
    green: 3%
    blue: 5%
  - id: my_green
    red: 0%
    green: 100%
    blue: 0%
  - id: my_blue
    red: 0%
    green: 0%
    blue: 100%
  - id: my_yellow
    red: 50%
    green: 50%
    blue: 0%
  - id: my_gray
    red: 30%
    green: 30%
    blue: 30%
font:
  # gfonts://family[@weight]
  - file:
      type: gfonts
      family: Inconsolata
      weight: 700
    id: roboto
    glyphs: |-
      !"%()+=,-_.:°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyzµ³>/
    size: 13
  - file:
      type: gfonts
      family: Inconsolata
      weight: 700
    id: roboto_small
    glyphs: |-
      !"%()+=,-_.:°0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyzµ³>/
    size: 11
image:
  - file: mdi:lightbulb
    id: icon_light
    resize: 16x16
  - file: mdi:air-filter
    id: icon_filter
    resize: 16x16
  - file: mdi:air-conditioner
    id: icon_ac
    resize: 18x18
  - file: mdi:fan
    id: icon_fan
    resize: 16x16
  - file: "thermometer_FILL0_wght400_GRAD0_opsz24.svg"
    id: icon_temp
    resize: 18x18
    type: TRANSPARENT_BINARY
    dither: FLOYDSTEINBERG
  - file: "humidity_mid_FILL0_wght400_GRAD0_opsz24.svg"
    id: icon_hum
    resize: 18x18
    type: TRANSPARENT_BINARY
    dither: FLOYDSTEINBERG
graph:
  # Show bare-minimum auto-ranged graph
  - id: ${id_prefix}_pm10_graph
    duration: 2min
    width: 50
    height: 20
    y_grid: 10000
    border: false
    traces:
      - sensor: ${id_prefix}_pm10
        line_type: SOLID
        line_thickness: 2
        color: my_blue
  - id: ${id_prefix}_pm25_graph
    duration: 2min
    width: 50
    height: 20
    y_grid: 10000
    border: false
    traces:
      - sensor: ${id_prefix}_pm25
        line_type: SOLID
        line_thickness: 2
        color: my_blue
  - id: ${id_prefix}_voc_graph
    duration: 2min
    width: 50
    height: 20
    max_value: 500
    min_value: 1
    y_grid: 500
    border: false
    traces:
      - sensor: ${id_prefix}_voc
        line_type: SOLID
        line_thickness: 2
        color: my_blue
  - id: ${id_prefix}_temperature_graph
    duration: 2min
    width: 50
    height: 20
    y_grid: 200
    traces:
      - sensor: ${id_prefix}_temperature_bottom
        line_type: SOLID
        line_thickness: 2
        color: my_blue
  - id: ${id_prefix}_humidity_graph
    duration: 2min
    width: 50
    height: 20
    y_grid: 200
    traces:
      - sensor: ${id_prefix}_humidity
        line_type: SOLID
        line_thickness: 2
        color: my_blue

display:
  - platform: st7735
    model: "INITR_18BLACKTAB"
    id: my_display
    #reset_pin: 33
    cs_pin: 27
    dc_pin: 13
    rotation: 180
    device_width: 128
    device_height: 160
    col_start: 0
    row_start: 0
    eight_bit_color: false
    update_interval: 300ms   
    pages:

      - id: page_environment
        lambda: |-
          it.print(64, 2, id(roboto),COLOR_ON,TextAlign::TOP_CENTER, "ENVIRONMENT");
          //we check for sen54!
          if(isnan(id(${id_prefix}_temperature_top).state)){
            it.print(64, 24, id(roboto),COLOR_ON,TextAlign::TOP_CENTER, "Waiting for");
            it.print(64, 40, id(roboto),COLOR_ON,TextAlign::TOP_CENTER, "sensor data");
            it.print(64, 56, id(roboto),COLOR_ON,TextAlign::TOP_CENTER, "...");
          }else{
            //it.fill(Color::BLACK);
            
            //PM 2.5 - LEFT
            
            //it.line(6, 19, 48, 19);
            uint tempoffsetY = 16;
            //it.print(3, tempoffsetY+20, id(roboto),COLOR_ON,TextAlign::BOTTOM_LEFT, "TEMP");
            it.image(3, tempoffsetY+2, id(icon_temp), ImageAlign::TOP_LEFT);
            it.graph(42, tempoffsetY+2, id(${id_prefix}_temperature_graph),Color::BLACK);
            it.printf(112, tempoffsetY+1, id(roboto), TextAlign::TOP_CENTER, "%.1f",  id(${id_prefix}_temperature_bottom).state);
            it.print(112, tempoffsetY+11, id(roboto_small), COLOR_ON, TextAlign::TOP_CENTER , "°C");

            uint humoffsetY = 40;
            //it.print(3, humoffsetY+20, id(roboto),COLOR_ON,TextAlign::BOTTOM_LEFT, "HUM");
            it.image(3, humoffsetY+2, id(icon_hum), ImageAlign::TOP_LEFT);
            it.graph(42, humoffsetY+2, id(${id_prefix}_humidity_graph),Color::BLACK);
            it.printf(112, humoffsetY+1, id(roboto), TextAlign::TOP_CENTER, "%.1f",  id(${id_prefix}_humidity).state);
            it.print(112, humoffsetY+11, id(roboto_small), COLOR_ON, TextAlign::TOP_CENTER , "%");

            uint pm10offsetY = 64;
            it.print(3, pm10offsetY+20, id(roboto),COLOR_ON,TextAlign::BOTTOM_LEFT, "PM1.0");
            it.graph(42, pm10offsetY+2, id(${id_prefix}_pm10_graph),Color::BLACK);
            it.printf(112, pm10offsetY+1, id(roboto), TextAlign::TOP_CENTER, "%.0f",  id(${id_prefix}_pm10).state);
            it.print(112, pm10offsetY+11, id(roboto_small), COLOR_ON, TextAlign::TOP_CENTER , "µg/m³");

            uint pm25offsetY = 88;
            it.print(3, pm25offsetY+20, id(roboto),COLOR_ON,TextAlign::BOTTOM_LEFT, "PM2.5");
            it.graph(42, pm25offsetY+2, id(${id_prefix}_pm25_graph),Color::BLACK);
            it.printf(112, pm25offsetY+1, id(roboto), TextAlign::TOP_CENTER, "%.0f",  id(${id_prefix}_pm25).state);
            it.print(112, pm25offsetY+11, id(roboto_small), COLOR_ON, TextAlign::TOP_CENTER , "µg/m³");

            uint vocoffsetY = 112;
            it.print(3, vocoffsetY+20, id(roboto),COLOR_ON,TextAlign::BOTTOM_LEFT, "VOC");
            it.graph(42, vocoffsetY+2, id(${id_prefix}_voc_graph),Color::BLACK);
            it.printf(112, vocoffsetY+5, id(roboto), TextAlign::TOP_CENTER, "%.0f",  id(${id_prefix}_voc).state);
            //it.print(112, vocoffsetY+10, id(roboto_small), COLOR_ON, TextAlign::TOP_CENTER , "%");

            uint iconY = 152;
            if(id(switch_light).state){
              it.image(16, iconY, id(icon_light), ImageAlign::BOTTOM_CENTER,id(my_green));
            }else{
              it.image(16, iconY, id(icon_light), ImageAlign::BOTTOM_CENTER,id(my_gray));
            }
          
            if(id(switch_filter).state){
              if(id(filter_a_auto) == 1 && id(auto_filter_sensor).state == 0.0){ //auto is on
                it.image(64, iconY, id(icon_filter), ImageAlign::BOTTOM_CENTER,id(my_yellow));
              }else{
                it.image(64, iconY, id(icon_filter), ImageAlign::BOTTOM_CENTER,id(my_green));
              }
            }else{
              it.image(64, iconY, id(icon_filter), ImageAlign::BOTTOM_CENTER,id(my_gray));
            }    

            if(id(switch_fan).state){
              
              if(id(ac_active) ==1){
                it.image(112, iconY+2, id(icon_ac), ImageAlign::BOTTOM_CENTER,id(my_green));
                //get target from climate?!?!
                it.printf(25, 30, id(roboto_small),COLOR_ON,TextAlign::BOTTOM_LEFT, "T: %d°c",id(ac_target_temp_value));
                auto hMode = "Off";
                if (id(heater_relais).state) {
                  hMode = "On";
                }
                it.printf(25, 43, id(roboto_small),COLOR_ON,TextAlign::BOTTOM_LEFT, "H: %s ",hMode);
              }else{
                it.image(112, iconY, id(icon_ac), ImageAlign::BOTTOM_CENTER,id(my_blue));
                it.print(25, 30, id(roboto_small),COLOR_ON,TextAlign::BOTTOM_LEFT, "T: OFF");
              }   

              
            }else{
              it.image(112, iconY, id(icon_ac), ImageAlign::BOTTOM_CENTER,id(my_gray));
            }   

            if(id(filter_a_auto) ==1){
              auto msg = "Auto-Run";
              if(id(auto_filter_sensor).state  == 0.0){
                msg = "Auto-Idle";
              }
              it.printf(64, 160, id(roboto_small),COLOR_ON,TextAlign::BOTTOM_CENTER, "%s",msg);
            }    
            
            
          }

      - id: page_settings
        lambda: |- 
          uint offsetY = 2;
          uint offsetX = 10;
          uint lineheight = 12;
          uint activeYoffset = offsetY+12;
          uint activeXoffset = offsetX/2-2;
      
          auto displayModeIndex = id(display_mode).active_index();
          auto settingsIndex = id(settings).active_index();
          if (settingsIndex.has_value()) {
            activeYoffset = settingsIndex.value();
            if(settingsIndex.value()==1 || settingsIndex.value()==6 || settingsIndex.value()==7 || settingsIndex.value()==8){
              activeXoffset=offsetX/2+3;
            }
          } else {
            ESP_LOGI("main", "No option is active");
          }
          if (displayModeIndex.has_value()) {
            if(displayModeIndex.value()==2 ){
              activeXoffset=98;
            }
          } else {
            ESP_LOGI("main", "No option is active");
          }
          
          it.print(64, offsetY, id(roboto_small),COLOR_ON,TextAlign::TOP_CENTER, "SETTINGS");
          it.print(offsetX, offsetY+(1*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, "A/C ........");
          it.print(offsetX, offsetY+(2*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, " TARGET C°..");
          it.print(offsetX, offsetY+(3*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, "LIGHT.......");
          it.print(offsetX, offsetY+(4*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, "FILTER......");
          it.print(offsetX, offsetY+(5*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, "FAN SPEED...");
          it.print(offsetX, offsetY+(6*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, "AUTO FILTER.");
          it.print(offsetX, offsetY+(7*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, " PM 2.5 >...");
          it.print(offsetX, offsetY+(8*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, " VOC >......");
          it.print(offsetX, offsetY+(9*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, " Runtime >..");
          it.print(offsetX, offsetY+(10*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_LEFT, "BACK");

          it.circle(offsetX/2-2, offsetY+(1*lineheight)+7, 3);
          it.circle(offsetX/2+3, offsetY+(2*lineheight)+7, 3);
          it.circle(offsetX/2-2, offsetY+(3*lineheight)+7, 3);
          it.circle(offsetX/2-2, offsetY+(4*lineheight)+7, 3);
          it.circle(offsetX/2-2, offsetY+(5*lineheight)+7, 3);
          it.circle(offsetX/2-2, offsetY+(6*lineheight)+7, 3);
          it.circle(offsetX/2+3, offsetY+(7*lineheight)+7, 3);
          it.circle(offsetX/2+3, offsetY+(8*lineheight)+7, 3);
          it.circle(offsetX/2+3, offsetY+(9*lineheight)+7, 3);
          it.circle(offsetX/2-2, offsetY+(10*lineheight)+7, 3);
          //mark selected setting!
          it.filled_circle(activeXoffset, offsetY+((activeYoffset+1)*lineheight)+7, 3);
          //print selected setting!
          //it.printf(64, offsetY+(8*lineheight), id(roboto_small), TextAlign::TOP_CENTER, "%s",  id(display_mode).state.c_str()  );   
          
          //values
          uint lightValue = id(light_a_brightness);
          uint filterValue = id(filter_a_speed);
          uint fanValue = id(fan_a_speed);

          if(id(ac_active) ==1){
            it.printf(125, offsetY+(1*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%s","ON");
          }else{
            it.printf(125, offsetY+(1*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%s","OFF");
          }   
          it.printf(125, offsetY+(2*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%d",id(ac_target_temp_value));       
          it.printf(125, offsetY+(3*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%d",lightValue);
          it.printf(125, offsetY+(4*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%d",filterValue);
          it.printf(125, offsetY+(5*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%d",fanValue);
          if(id(filter_a_auto) ==1){
            it.printf(125, offsetY+(6*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%s","ON");
          }else{
            it.printf(125, offsetY+(6*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%s","OFF");
          }
          it.printf(125, offsetY+(7*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%d",id(auto_filter_pm_min_value));
          it.printf(125, offsetY+(8*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%d",id(auto_filter_voc_min_value));
          it.printf(125, offsetY+(9*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%dh",id(filter_runtime_value)/60);
          it.printf(125, offsetY+(10*lineheight), id(roboto_small),COLOR_ON,TextAlign::TOP_RIGHT, "%dm",id(filter_runtime_value)%60);
          
          it.printf(85, 160, id(roboto_small),COLOR_ON,TextAlign::BOTTOM_CENTER, "Heater: %.1f°C",id(${id_prefix}_temperature_heater).state);
          it.printf(85, 150, id(roboto_small),COLOR_ON,TextAlign::BOTTOM_CENTER, "Enclosure: %.1f°C",id(${id_prefix}_temperature_top).state);

          ESP_LOGI("main", "auto_filter_pm_max:  %d is active", id(auto_filter_pm_min_value));

dallas:
  - pin: GPIO15
    update_interval: 10s 
sensor:
  - platform: dallas
    index: 1
    id: ${id_prefix}_temperature_heater
    name: "Heater temperature ${node_name}"
  - platform: dallas
    index: 0
    id: ${id_prefix}_temperature_bottom
    name:  "Temperature bottom ${node_name}"
  - platform: template
    id: "auto_filter_sensor"
    internal: true
    lambda: |-
      id(update_filter)->execute();
      id(update_ac)->execute();
      if (id(filter_a_auto) == 1) {
        if(id(${id_prefix}_pm25).state>id(auto_filter_pm_min_value) || id(${id_prefix}_voc).state>id(auto_filter_voc_min_value)){
          return 1.0;
        }
        return 0.0;
      } else {
        //on and no auto, so...
        return 0.0;
      }
    update_interval: 1s
  - platform: sen5x
    id: sen54
    pm_1_0:
      name: " PM <1µm Weight concentration ${node_name}"
      id: ${id_prefix}_pm10
      accuracy_decimals: 1
      filters:
        - sliding_window_moving_average:
            window_size: 9
            send_every: 1
    pm_2_5:
      name: " PM <2.5µm Weight concentration ${node_name}"
      id: ${id_prefix}_pm25
      accuracy_decimals: 1
      filters:
        - sliding_window_moving_average:
            window_size: 9
            send_every: 1
    pm_4_0:
      name: " PM <4µm Weight concentration ${node_name}"
      id: ${id_prefix}_pm40
      accuracy_decimals: 1
    pm_10_0:
      name: " PM <10µm Weight concentration ${node_name}"
      id: ${id_prefix}_pm100
      accuracy_decimals: 1
    temperature:
      name: "Temperature top ${node_name}"
      accuracy_decimals: 1
      id: ${id_prefix}_temperature_top
    humidity:
      name: "Humidity ${node_name}"
      accuracy_decimals: 0
      id: ${id_prefix}_humidity
    voc:
      name: "VOC ${node_name}"
      id: ${id_prefix}_voc
      algorithm_tuning:
        index_offset: 100
        learning_time_offset_hours: 12
        learning_time_gain_hours: 12
        gating_max_duration_minutes: 180
        std_initial: 50
        gain_factor: 230
      filters:
        - sliding_window_moving_average:
            window_size: 9
            send_every: 1
    temperature_compensation:
      offset: 0
      normalized_offset_slope: 0
      time_constant: 0
    acceleration_mode: low
    store_baseline: true
    address: 0x69
    update_interval: 10s

  - platform: rotary_encoder
    name: "Rotary Encoder"
    internal: true
    id: rotary
    pin_a: GPIO05
    pin_b: GPIO17
    min_value: 1
    max_value: 20
    on_clockwise:
    - if:
        condition:
          lambda: 'return (strcmp(id(display_mode).state.c_str(), "environment") == 0);'
        then:
          - select.set_index:
              id: display_mode
              index: 1
    - if:
        condition:
          lambda: 'return (strcmp(id(display_mode).state.c_str(), "settings") == 0);'
        then:
          - select.next:
              id: settings
              cycle: true
    - if:
        condition:
          lambda: 'return (strcmp(id(display_mode).state.c_str(), "single") == 0);'
        then:
          - lambda: |-
              ESP_LOGI("main", "UP NOW:  %d is active", id(light_a_brightness));
              id(update_setting)->execute(1);
    - lambda: |-
        id(display_off_timer)->execute();
    on_anticlockwise:  
    - if:
        condition:
          lambda: 'return (strcmp(id(display_mode).state.c_str(), "environment") == 0);'
        then:
          - select.set_index:
              id: display_mode
              index: 1
    - if:
        condition:
          lambda: 'return (strcmp(id(display_mode).state.c_str(), "settings") == 0);'
        then:
          - select.previous:
              id: settings
              cycle: true
    - if:
        condition:
          lambda: 'return (strcmp(id(display_mode).state.c_str(), "single") == 0 );'
        then:
          - lambda: |-
              id(update_setting)->execute(0);
    - lambda: |-
        id(display_off_timer)->execute();

binary_sensor:
  - platform: gpio
    pin:
      mcp23xxx: mcp23017_hub
      number: 3
      mode:
        input: true
      inverted: true
    name: "Rotary"
    internal: true
    on_multi_click:
    - timing:
        - ON for at most 1s
        - OFF for at least 0.5s
      then:
        - lambda: |-
            //ENVIRONMENT
            uint clickHandled = 0;
            if(strcmp(id(display_mode).state.c_str(), "environment") == 0){
              auto displayCall = id(display_mode).make_call();
              displayCall.set_option("settings");
              displayCall.perform();
              clickHandled = 1;
            }
            //SINGLE
            if(clickHandled==0 && strcmp(id(display_mode).state.c_str(), "single") ==0){
              auto displayCall = id(display_mode).make_call();
              displayCall.set_option("settings");
              displayCall.perform();
              clickHandled = 1;
            }

            //SETTINGS
            // back -> go back to ENVIRONMENT
            if(clickHandled==0 && strcmp(id(display_mode).state.c_str(), "settings") ==0){
              if(strcmp(id(settings).state.c_str(), "back") == 0){
                auto displayCall = id(display_mode).make_call();
                displayCall.set_option("environment");
                displayCall.perform();
              }else{
                auto displayCall = id(display_mode).make_call();
                displayCall.set_option("single");
                displayCall.perform();
              }
              clickHandled = 1;
            }
            id(display_off_timer)->execute();
  - platform: gpio
    pin: 
      mcp23xxx: mcp23017_hub
      number: 0
      mode:
        input: true
        pullup: true
      inverted: true
    id: switch_light
    publish_initial_state: true
    on_state:
      - lambda: |-
          if(id(switch_light).state){
            id(update_light)->execute();
          }else{
            auto call = id(light_a).turn_off();
            call.set_transition_length(0); // in ms
            call.set_brightness(0);
            call.perform();
          }
          id(display_off_timer)->execute();
    filters:
      - delayed_on_off:
          time_on: 200ms
          time_off: 200ms  
  - platform: gpio
    pin: 
      mcp23xxx: mcp23017_hub
      number: 2
      mode:
        input: true
        pullup: true
      inverted: true
    id: switch_filter
    publish_initial_state: true
    on_state:
      - lambda: |-
          id(update_filter)->execute();
          id(display_off_timer)->execute();
    filters:
      - delayed_on_off:
          time_on: 200ms
          time_off: 200ms 
  - platform: gpio
    pin: 
      mcp23xxx: mcp23017_hub
      number: 1
      mode:
        input: true
        pullup: true
      inverted: true
    id: switch_fan
    publish_initial_state: true
    on_state:
      - lambda: |-
          if(id(switch_fan).state){
            id(update_fan)->execute();
          }else{
            auto call = id(fan_a).turn_off();
            call.set_transition_length(0); // in ms
            call.set_brightness(0);
            call.perform();
          }
          id(display_off_timer)->execute();
    filters:
      - delayed_on_off:
          time_on: 200ms
          time_off: 200ms  
  - platform: gpio
    pin: 
      mcp23xxx: mcp23017_hub
      number: 4
      mode:
        input: true
        pullup: true
      inverted: true
    id: switch_printer
    publish_initial_state: true
    on_state:
      - logger.log: PRINTER
      - lambda: |-
          if(id(switch_printer).state){
            id(printer_relais).turn_on();
          }else{
            id(printer_relais).turn_off();
          }
          id(display_off_timer)->execute();
    filters:
      - delayed_on_off:
          time_on: 200ms
          time_off: 200ms 
  - platform: template
    name: "Light ${name}"
    lambda: |-
      if(id(light_a).current_values.is_on() && id(light_a).current_values.get_brightness() > 0){
        return true;
      } else {
        return false;
      } 
climate:
  - platform: thermostat
    name: "Enclosure Climate Controller"
    internal: true
    id: my_climate
    sensor: ${id_prefix}_temperature_bottom
    visual:
      min_temperature: 18
      max_temperature: 55
      temperature_step: 1
    min_cooling_off_time: 60s
    min_cooling_run_time: 30s
    min_heating_off_time: 30s
    min_heating_run_time: 30s
    min_idle_time: 60s
    cool_action:
      - script.execute: update_ac
    heat_action:
      - script.execute: update_ac
    idle_action:
      - script.execute: update_ac
    on_state:
      - script.execute: update_ac
    on_control:
      - script.execute: update_ac
    default_preset: default
    preset:
      - name: default
        default_target_temperature_low: 25
        default_target_temperature_high: 26
        mode: HEAT_COOL
output:
  - platform: ledc
    pin: GPIO16
    id: gpio_16
    frequency: 25kHz
    channel: 0
  - platform: ledc
    pin: GPIO23
    id: gpio_23
    channel: 2
    frequency: 25kHz
  - platform: ledc
    pin: GPIO19
    id: gpio_19
    channel: 4
    frequency: 25kHz
  - platform: ledc
    id: pwm_servo
    pin: GPIO18
    channel: 6
    frequency: 50Hz   
  - platform: gpio
    pin: GPIO04
#      mcp23xxx: mcp23017_hub
#      number: 13
    id: lcd_out

number:
  - platform: template
    id: servo_pos
    min_value: -100
    initial_value: 0
    max_value: 100
    step: 10
    optimistic: true
  - platform: template
    name: "AC Target Temp ${name}"
    id: ${id_prefix}_ac_target_temp
    optimistic: false
    min_value: 15
    max_value: 50
    step: 1
    device_class: TEMPERATURE
    set_action:
      - logger.log:
          format: "Chosen option: %f"
          args: ["x"]
      - lambda: |-
          ESP_LOGI("main", "Value of my number: %d", (int)x);
          id(ac_target_temp_value) = (int)x;
          //ensure new value is taken 
          id(update_ac_target)->execute();
    lambda: 
      return id(ac_target_temp_value);
        
servo:
  - id: lid_servo
    output: pwm_servo
    transition_length: 1s
    auto_detach_time: 500ms

switch:
  - platform: gpio
    pin:  
      number: GPIO25
      inverted: true
    id: printer_relais
    restore_mode: ALWAYS_ON
  - platform: gpio
    pin: GPIO33
    id: heater_relais
    restore_mode: ALWAYS_OFF
  - platform: template
    name: "AC ${name}"
    id: ${id_prefix}_ac_mode_switch
    lambda: |-
      if(id(ac_active)==1){
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - lambda: |-
          id(ac_active)=1;
          id(update_ac_target)->execute(); 
    turn_off_action:
      - lambda: |-
          id(ac_active)=0;
          id(update_ac_target)->execute(); 
# light is also used to control the speed of the fans
light:
  - platform: monochromatic
    output: gpio_16
    id: light_a
    name: "Prusa Enclosure - Light"
    internal: true
    restore_mode: ALWAYS_OFF 
  - platform: monochromatic
    output: gpio_23
    id: filter_a
    name: "Prusa Enclosure - Air Filter"
    internal: true
    restore_mode: ALWAYS_OFF 
  - platform: monochromatic
    output: gpio_19
    id: fan_a
    name: "Prusa Enclosure - Fan"
    restore_mode: ALWAYS_OFF 
    internal: true
  - platform: binary
    id: "lcd_light"
    restore_mode: ALWAYS_ON 
    output: lcd_out
    internal: true


